//   ▄▄       ▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄▄▄       ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄
//  ▐░░▌     ▐░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌     ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
//  ▐░▌░▌   ▐░▐░▌▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀▀▀▀▀█░▌     ▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀█░▌
//  ▐░▌▐░▌ ▐░▌▐░▌▐░▌       ▐░▌▐░▌       ▐░▌          ▐░▌     ▐░▌          ▐░▌       ▐░▌
//  ▐░▌ ▐░▐░▌ ▐░▌▐░█▄▄▄▄▄▄▄█░▌▐░▌       ▐░▌ ▄▄▄▄▄▄▄▄▄█░▌     ▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌
//  ▐░▌  ▐░▌  ▐░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌▐░░░░░░░░░░░▌     ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
//  ▐░▌   ▀   ▐░▌▐░█▀▀▀▀▀▀▀█░▌▐░▌       ▐░▌▐░█▀▀▀▀▀▀▀▀▀      ▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀█░█▀▀
//  ▐░▌       ▐░▌▐░▌       ▐░▌▐░▌       ▐░▌▐░▌               ▐░▌          ▐░▌     ▐░▌
//  ▐░▌       ▐░▌▐░▌       ▐░▌▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄      ▐░▌          ▐░▌      ▐░▌
//  ▐░▌       ▐░▌▐░▌       ▐░▌▐░░░░░░░░░░▌ ▐░░░░░░░░░░░▌     ▐░▌          ▐░▌       ▐░▌
//   ▀         ▀  ▀         ▀  ▀▀▀▀▀▀▀▀▀▀   ▀▀▀▀▀▀▀▀▀▀▀       ▀            ▀         ▀
//
//   ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄
//  ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
//  ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀█░█▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀  ▀▀▀▀█░█▀▀▀▀
//  ▐░▌       ▐░▌▐░▌       ▐░▌▐░▌       ▐░▌      ▐░▌    ▐░▌          ▐░▌               ▐░▌
//  ▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄█░▌▐░▌       ▐░▌      ▐░▌    ▐░█▄▄▄▄▄▄▄▄▄ ▐░▌               ▐░▌
//  ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌      ▐░▌    ▐░░░░░░░░░░░▌▐░▌               ▐░▌
//  ▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀█░█▀▀ ▐░▌       ▐░▌      ▐░▌    ▐░█▀▀▀▀▀▀▀▀▀ ▐░▌               ▐░▌
//  ▐░▌          ▐░▌     ▐░▌  ▐░▌       ▐░▌      ▐░▌    ▐░▌          ▐░▌               ▐░▌
//  ▐░▌          ▐░▌      ▐░▌ ▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄▄█░▌    ▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄▄▄      ▐░▌
//  ▐░▌          ▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░▌    ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌     ▐░▌
//   ▀            ▀         ▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀      ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀       ▀
//
//
//
//
#include <iostream> // I:O stream
#include <iomanip> // I:O manipulation
#include <array> // Array STL
#include <string> // String
#include <sstream> // Convert string to int
#include <cstdlib> // exit()
#include <algorithm>

#include "morpion.hpp"

const int BOARD_LIMIT {3};
/** \brief
 *  Initialise une nouvelle partis,  cad,
 *  La map est remplis de caractere '-',
 *  Et la structure est initialiser avec des valeur par defaut .
 * \param
 * \param
 * \return Retourne une structure de type TicTacToe
 *
 */

TicTacToe createNewGame()
{
    TicTacToe tictactoe{false, 0, 0, Switch::CIRCLE, {'O', 'X'}, {0, 0}};

    // Initilisation

    for(size_t i{0}; i < BOARD_LIMIT; i++)
    {
        for(size_t j{0}; j < BOARD_LIMIT; j++)
        {
            tictactoe.board.at(i).at(j) = '-'; // On place un '-' pour signifie un emplacement libre
        }
    }

    return tictactoe;
}
/** \brief
 *  Récupere le tableau de tictactoe et selon les coordonnées x et y et le caractere
 *  fournis en parametre la fonction place le caractere dans le tableau
 *  Si le joueur mets sur des coordonnées déja jouer il perd sont tour !
 * \param Le tableau std::array
 * \param La position x
 * \param La position y
 * \param Le caractere
 * \return
 *
 */
void setPosition(std::array<std::array<char, 3>, 3>& board, int x, int y, char player)
{
    if(board.at(y).at(x) == '-')
        board.at(y).at(x) = player;
    else
        std::cout << "(" << player << ")" << "-> You play in your own position ." <<  std::endl;
}
/** \brief
 *  Affiche le contenu du tableau
 * \param Le tableau etant une référence de class std::array
 * \param
 * \return
 *
 */
void printArray(const std::array<std::array<char, 3>, 3>& board)
{
    for(size_t i{0}; i < BOARD_LIMIT; i++) // i représente l'ordonnées les y
    {
        for(size_t j{0}; j < BOARD_LIMIT; j++) // j représente l'abscice les x
        {
            std::cout << " " << board.at(i).at(j);
        }
        std::cout << std::endl;
    }
    std::cout << "[******************]" << std::endl;
}
/** \brief
 *  Convertit l'input utilisateur en entier qui traduit,
 *  le nombre convertit en coordonnées 2D
 * \param Une structure TicTacToe
 * \param Une class std::string
 * \return
 *
 */

void transformInputToCoordinate(TicTacToe& tictactoe, std::string str)
{
    std::istringstream strStream {str};
    int position{0};

    strStream >> position;

    switch(position)
    {
    case 7:
        tictactoe.position.x = 0;
        tictactoe.position.y = 0;
        break;
    case 8:
        tictactoe.position.x = 1;
        tictactoe.position.y = 0;
        break;
    case 9:
        tictactoe.position.x = 2;
        tictactoe.position.y = 0;
        break;

    case 4:
        tictactoe.position.x = 0;
        tictactoe.position.y = 1;
        break;
     case 5:
        tictactoe.position.x = 1;
        tictactoe.position.y = 1;
        break;
     case 6:
        tictactoe.position.x = 2;
        tictactoe.position.y = 1;
        break;
     case 1:
        tictactoe.position.x = 0;
        tictactoe.position.y = 2;
        break;
    case 2:
        tictactoe.position.x = 1;
        tictactoe.position.y = 2;
        break;
    case 3:
        tictactoe.position.x = 2;
        tictactoe.position.y = 2;
        break;
    default:
        std::cout << "Unknow position !" << std::endl;
        exit(EXIT_FAILURE);
    }
}
void transformInputToCoordinate(TicTacToe& tictactoe, int position)
{
     switch(position)
    {
    case 7:
        tictactoe.position.x = 0;
        tictactoe.position.y = 0;
        break;
    case 8:
        tictactoe.position.x = 1;
        tictactoe.position.y = 0;
        break;
    case 9:
        tictactoe.position.x = 2;
        tictactoe.position.y = 0;
        break;

    case 4:
        tictactoe.position.x = 0;
        tictactoe.position.y = 1;
        break;
     case 5:
        tictactoe.position.x = 1;
        tictactoe.position.y = 1;
        break;
     case 6:
        tictactoe.position.x = 2;
        tictactoe.position.y = 1;
        break;
     case 1:
        tictactoe.position.x = 0;
        tictactoe.position.y = 2;
        break;
    case 2:
        tictactoe.position.x = 1;
        tictactoe.position.y = 2;
        break;
    case 3:
        tictactoe.position.x = 2;
        tictactoe.position.y = 2;
        break;
    default:
        std::cout << "Unknow position !" << std::endl;
        exit(EXIT_FAILURE);
    }
}


/** \brief
 *  Verifie les rond et les croix en diagonale, ligne et colone
 *  Si alignement on quitte la partis
 * \param Une structure TicTacToe
 * \param
 * \return
 *
 */

void check(TicTacToe& tictactoe)
{
    size_t i{0};
    size_t j{0};

    int count{0};

        // Verification des 'O' ligne par ligne
    for(i = 0; i < BOARD_LIMIT; i++)
    {
        for(j = 0; j < BOARD_LIMIT; j++)
        {
            if(tictactoe.board.at(i).at(j) == tictactoe.player.at(0))
            {
                count++;
                if(count == BOARD_LIMIT)
                {
                    std::cout << "Game Overs !" << std::endl;
                    tictactoe.gameOver = true;
                    return;
                }
            }
        }
        count = 0;
    }
    count = 0;
    for(i = 0; i < BOARD_LIMIT; i++)
    {
        for(j = 0; j < BOARD_LIMIT; j++)
        {
            if(tictactoe.board.at(i).at(j) == tictactoe.player.at(1))
            {
                count++;
                if(count == BOARD_LIMIT)
                {
                    std::cout << "Game Overs !" << std::endl;
                    tictactoe.gameOver = true;
                    return;
                }
            }
        }
        count = 0;
    }
    count = 0;
        // Check par colone
    for(j = 0; j < BOARD_LIMIT; j++)
    {
        for(i = 0; i < BOARD_LIMIT; i++)
        {
            if(tictactoe.board.at(i).at(j) == tictactoe.player.at(0))
            {
                count++;
                if(count == BOARD_LIMIT)
                {
                    std::cout << "Game Overs !" << std::endl;
                    tictactoe.gameOver = true;
                    return;
                }
            }
        }
        count = 0;
    }
    count = 0;
           // Check par colone
    for(j = 0; j < BOARD_LIMIT; j++)
    {
        for(i = 0; i < BOARD_LIMIT; i++)
        {
            if(tictactoe.board.at(i).at(j) == tictactoe.player.at(1))
            {
                count++;
                if(count == BOARD_LIMIT)
                {
                    std::cout << "Game Overs !" << std::endl;
                    tictactoe.gameOver = true;
                    return;
                }
            }
        }
        count = 0;
    }
    count = 0;
// Diagonale
    i = 0;
    while(i < BOARD_LIMIT)
    {
        if(tictactoe.board.at(i).at(i) == tictactoe.player.at(0))
        {
            count++;
            if(count == BOARD_LIMIT)
            {
                std::cout << "Game Overs !" << std::endl;
                tictactoe.gameOver = true;
                return;
            }
        }
        i++;
    }
    count = 0;

    i = 0;
    while(i < BOARD_LIMIT)
    {
        if(tictactoe.board.at(i).at(i) == tictactoe.player.at(1))
        {
            count++;
            if(count == BOARD_LIMIT)
            {
                std::cout << "Game Overs !" << std::endl;
                tictactoe.gameOver = true;
                return;
            }
        }
        i++;
    }

    count = 0;
    i = 0, j = 2;
    while(i < BOARD_LIMIT)
    {
        if(tictactoe.board.at(i).at(j) == tictactoe.player.at(0))
        {
            count++;
            if(count == BOARD_LIMIT)
            {
                std::cout << "Game Overs !" << std::endl;
                tictactoe.gameOver = true;
                return;
            }
        }

        i++;
        j--;
    }

    count = 0;
    i = 0, j = 2;
    while(i < BOARD_LIMIT)
    {
        if(tictactoe.board.at(i).at(j) == tictactoe.player.at(1))
        {
            count++;
            if(count == BOARD_LIMIT)
            {
                std::cout << "Game Overs !" << std::endl;
                tictactoe.gameOver = true;
                return;
            }
        }

        i++;
        j--;
    }
}

int iaComputer(TicTacToe& tictactoe)
{
    int gameValue{0};
    std::array<int, 9> nodesPlayer;
    std::array<int, 3> minimumPlay;

    for(size_t i{0}; i < 9; i++)
    {
        nodesPlayer.at(i) = 10;
    }
    int nodesPlayerIndex{0};
    for(size_t i{0}; i < BOARD_LIMIT; i++)
    {
        for(size_t j{0}; j < BOARD_LIMIT; j++)
        {
            if(tictactoe.board.at(i).at(j) == '-')
            {
                nodesPlayerIndex++;
                if(i == 0 && j ==0)
                    nodesPlayer.at(nodesPlayerIndex) = 7;
                else if(i == 0 && j == 1)
                    nodesPlayer.at(nodesPlayerIndex) = 8;
                else if (i == 0 && j==2)
                    nodesPlayer.at(nodesPlayerIndex) = 9;
                else if (i == 1 && j == 0)
                    nodesPlayer.at(nodesPlayerIndex) = 4;
                else if(i == 1 && j == 1)
                    nodesPlayer.at(nodesPlayerIndex) = 5;
                else if (i == 1 && j == 2)
                    nodesPlayer.at(nodesPlayerIndex) = 6;
                else if (i == 2 && j == 0)
                    nodesPlayer.at(nodesPlayerIndex) = 1;
                else if (i == 2 && j == 1)
                    nodesPlayer.at(nodesPlayerIndex) = 2;
                else
                    nodesPlayer.at(nodesPlayerIndex) = 3;
            }
        }
    }

    std::cout << "DEBUG" << std::endl;
    std::sort(nodesPlayer.begin(), nodesPlayer.end());


    minimumPlay.at(0) = nodesPlayer.at(0);
    minimumPlay.at(1) = nodesPlayer.at(1);
    minimumPlay.at(2) = nodesPlayer.at(2);

    gameValue = minimumPlay.at(0);

    for(size_t i{0}; i < 3; i++)
    {
        if(gameValue < minimumPlay.at(i))
        {
            gameValue = minimumPlay.at(i);
        }
    }

    std::cout << gameValue << std::endl;

    return gameValue;
}


